= Overtone

== Rhythm and Time

* keep a global BPM 
* define time (ms) values for 
 - whole, half, quarter, eighth, sixteenth, 32... (W, H, Q, E, S, T...)

; compute ms or fraction of a second for a whole note at the given tempo and time signature
(def tempo 120) ; bpm
(def beat 1/4)  ; time signature
(rhythm H tempo beat)

* quantization
 - (quantize list-of-events step-size)
 - quantize event times to fall on multiples of step-size

* rescale a series of notes to a new BPM or signature

* Pattern based rhythms
 - define piano rolls of triggers and assign instruments to each channel

; Using 1/4 notes
(def house-beat {:kick  [O _ _ _ O _ _ _ O _ _ _ O _ _ _]
                 :o-hat [_ _ O _ _ _ O _ _ _ O _ _ _ O _]
                 :clap  [_ _ _ _ O _ _ _ _ _ _ _ O _ _ _]})

(make-beat house-beat {:base "kick.wav" 
                       :o-hat "hat.wav"
                       :clap "clap.wav"})

* Archaeopteryx style rhythm queue, so you can push no rhythms on to start playing, but then pop off to go back to where you were before.

* Keep a ref var pointing to the current rhythm function(s)
-- returns true if it should play on the next beat?
-- modify the ref and you get a new beat on the fly


== Notes

* frequency
* duration
* attack velocity
* decay velocity

(note freq dur attack decay) ; full spec
(note C) ; note with default octave 4
(note Cs) ; C-sharp?
(note C2)

* modifiers for slides, bends, and atonal stuff?

* conversion between notes to hz 
(hz my-note)
(note my-hz)

; list of notes played in default octave
(play [C D E F G A B C])

; notes as arguments
(play C D E F G A B C)

; specify octaves
(play [C0 D1 E0 F1 A3 B0 C1])

; relative representation rather than note based, moves from previous note
(play [A2 0 5 -5 9 0 -9])
; or make everything relative to the start note
(play [A2 0 5 0 9 9 0])

== Scales

; Get all notes in specified scale
(scale C-maj)
(scale Bf-min) ; b-flat minor
(def major [2 2 1 2 2 2 1])
(scale 2 D3 major) ; generate 2 octaves of D major starting at 3rd octave

* probably want some kind of mechanisms to mask notes in a series, for example to only play the 1st and 3rd notes of a scale for a few bars...


== Chords

* build chords using interval sequences applied to scale sequences
* have chord modifiers that can make things diminished, etc.
* have genre labeled modifier presets, for example for jazzy, african, or latin chords

== Grooves

A groove represents a pattern of velocities that is applied to a sequence of notes.  They are used to change the feel
of a sequence of notes and to make it feel more organic.

* swing
* jazz groove, latin groove
* techno grooves (hard on beat one)

== Note Modifiers:

* (transpose note-or-notes amount)
* (invert notes)  ; upside down
* (reverse notes) ; mirror view
* (shift notes steps)   ; move up/down some number of steps

== Musical Generation

* various forms of random that can return random notes out of a set (e.g. a scale), weighted random from a set, random between a set range, etc..

(pick n my-scale) ; pick n random notes from a scale
(pick n my-scale weights) ; "..." with weighted probabilities

* arpeggiators

* shuffle notes (randomize a sequence)

* Many musical packages have some notion of a repeating process that is used to generate notes.  In clojure we can just use the built-in support for lazy sequences to implement the same thing.
 - repeat, cycle, iterate, etc...

* Sequence generators 
 - probabilistic arpeggiator
 - take a rhythym seq, note seq, and groove seq
 - latin sounds
 - house sounds
 - minimal techno sounds
 - drum and bass sounds

* create a library of sequence modifiers and harmonizers


-------------------------

Related Projects:

* Common Music
** http://commonmusic.sourceforge.net/cm/res/doc/cm.html#toolbox

* JFugue
** http://www.jfugue.org/javadoc/index.html

* JMusic
** http://jmusic.ci.qut.edu.au/

* Impromptu
** http://impromptu.moso.com.au/

* Fluxus, Fluxa and LiveNoiseTools
** http://impromptu.moso.com.au/

* csound
** http://www.csounds.com/

* Super Collider
** http://supercollider.sourceforge.net/

------------------------------

= Livecoding

Clojure source editor:
* Custom editor (incorporate the Waterfront IDE???)
* Code in vim/emacs with socket connection to audio/graphics engine

Musical programming:
* musical structure
 - notes, scales, chords, arpeggios (jm.JMC)
* musical flow
 - processes 
   * e.g. Common Music -> http://commonmusic.sourceforge.net/cm/res/doc/cm.html#processes
 - recursion in time
   * impromptu style
* Need accurate source of timing (nanoTime, ScheduledExecutorService, audio API or OpenGL timers???)

= Visualization and interface 
Use: 
* penumbra GL/shaders for clojure http://github.com/ztellman/penumbra/tree/master
* Game engine http://www.jmonkeyengine.com/

= Distributed, real-time jamming
Use: Plasma, graph based networking

= Cloud storage and collaboration 
Use: google app-engine/wave cloud server

= VST Plugin capabliity
Use: jVSTWrapper (http://jvstwrapper.sourceforge.net/

= Computer vision (multi-touch detection and object tracking)

Touch APIs:
* Multitouch lib from TU-Berlin http://code.google.com/p/multitouch/
* Sparsh UI http://code.google.com/p/sparsh-ui/

Custom image processing:
* http://javavis.sourceforge.net/
* Java OpenCV http://ubaa.net/shared/processing/opencv/
* Or implement processing pipeline in C++ with OpenCV and use 
  clojure-jna to interface: http://github.com/Chouser/clojure-jna/tree/master

-------------------------------------------------

TODO: 

* Figure out mutex problem in Fluxa's async sample loader
 - the loading loop does a trylock and fails, so it doesn't load samples... I put in a spin loop hack for now...
